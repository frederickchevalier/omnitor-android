{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Omnitor for Android","body":"Omnitor for Android is the open-source version of one of my old projects. The app records the user's mobile phone consumption--sent and received SMS, incoming and outgoing calls, bytes of data sent and received via mobile internet and WiFi/LAN, and the network roaming state as these transactions occur. These logs are uploaded to a server on a regular schedule, and are used by the client to recommend to the user the best mobile plan available on a local telco.\r\n\r\n## First run\r\n\r\nOn first launch, the app generates a UUID to uniquely identify the installation. It then remembers information such as the time of first launch, the current network roaming state, and the current values of Android's built-in data counters, if supported in the device.\r\n\r\nThen, a background thread is fired to upload device information in the below JSON format. If the upload fails, Ominitor attempts again in the next minute.\r\n\r\n```javascript\r\n{\r\n    \"uuid\" : (string),\r\n    \"type\" : \"device\", // type of log\r\n    \"model\" : (string),\r\n    \"manufacturer\" : (string),\r\n    \"first_run\" : (long) // time when first run\r\n}\r\n```\r\n\r\nFinally, alarms are set for regularly scheduled tasks: the outgoing SMS logger (<code>OutSmsLogger</code>), the data consumption logger (<code>DataLogger</code>), and the <code>Uploader</code>. For this project, those three tasks are scheduled to be fired every 1 minute.\r\n\r\nThe app doesn't do anything special whenever it is launched after the first time.\r\n\r\n## Sign up\r\n\r\nIf the user decides to sign up, Omnitor simply uploads the user's email together with the app's UUID.\r\n\r\n```javascript\r\n{\r\n    \"uuid\" : (string),\r\n    \"type\" : \"user\",\r\n    \"email\" : (string)\r\n}\r\n```\r\n\r\nIf the upload fails, the app simply tries again the next minute. If successful, whenever the app is launched, a screen with the following message will always show up:\r\n\r\n```\r\nHello! Don't mind us--we're working in the background.\r\nGo do your stuff as usual.\r\n```\r\n\r\n## Incoming SMS\r\n\r\nWhenever a text message arrives, <code>InSmsLogger</code> is fired and the following information about the SMS is stored in SQLite.\r\n\r\n```javascript\r\n{\r\n    \"uuid\" : (string),\r\n    \"type\" : \"in_sms\",\r\n    \"number\" : (string), // the sender\r\n    \"sim_number\" : (string), // the user's mobile phone number\r\n    \"time\" : (long),\r\n    \"length\" : (int), // number of characters in the SMS\r\n    \"roaming\" : (boolean) // network roaming state upon receive\r\n}\r\n```\r\n\r\n## Outgoing SMS\r\n\r\n<code>OutSmsLogger</code> is fired on a set schedule because there's currently no public API in Android to monitor outgoing SMSes as they are sent. The logger looks at the SMS messages that are sent and logs the following info.\r\n\r\n```javascript\r\n{\r\n    \"uuid\" : (string),\r\n    \"type\" : \"out_sms\",\r\n    \"number\" : (string), // the recipient\r\n    \"sim_number\" : (string), // user's number\r\n    \"time\" : (long),\r\n    \"length\" : (int), // number of characters in the SMS\r\n    \"roaming\" : (boolean) // network roaming state upon send\r\n}\r\n```\r\n\r\nIf the user deletes all the messages before the logger is fired, then it will record nothing.\r\n\r\n## Incoming calls\r\n\r\nAfter an incoming call, <code>InCallLogger</code> fires a background thread that records the following information about the call.\r\n\r\n```javascript\r\n{\r\n    \"uuid\" : (string),\r\n    \"type\" : \"in_call\",\r\n    \"number\" : (string), // the caller\r\n    \"sim_number\" : (string), // user's number\r\n    \"time_started\" : (long),\r\n    \"time_answered\" : (long),\r\n    \"time_ended\" : (long),\r\n    \"roaming\" : (boolean)\r\n}\r\n```\r\n\r\n## Outgoing calls\r\n\r\nAfter an outgoing call, <code>OutCallLogger</code> fires a background thread that records similar information as with incoming calls, except for <code>time_answered</code>. There currently are no public APIs in Android to detect when the other line picks up the call our user is making.\r\n\r\n```javascript\r\n{\r\n    \"uuid\" : (string),\r\n    \"type\" : \"out_call\",\r\n    \"number\" : (string), // the target number\r\n    \"sim_number\" : (string), // user's number\r\n    \"time_started\" : (long),\r\n    \"time_ended\" : (long),\r\n    \"roaming\" : (boolean)\r\n}\r\n```\r\n\r\n## Data consumption\r\n\r\nOmnitor distinguishes between data consumption over WiFi/LAN and over mobile internet (3G, 4G). As mentioned earlier, the values of Android's built-in data counters (in bytes) are remembered upon the app's first launch. Since <code>DataLogger</code> is fired every minute, it simply subtracts the new values of those counters and creates a log in the format below.\r\n\r\n```javascript\r\n{\r\n    \"uuid\" : (string),\r\n    \"type\" : \"data\",\r\n    \"network_sent\" : (long), // bytes sent, WiFi/LAN\r\n    \"network_received\" : (long), // bytes received, WiFi/LAN\r\n    \"mobile_sent\" : (long), // bytes sent, mobile data\r\n    \"mobile_received\" : (long), // bytes received, mobile data\r\n    \"roaming\" : (boolean)\r\n}\r\n```\r\n\r\n## Roaming\r\n\r\nCaution: This is the only part of the code that is based on StackOverflow research and is left **UNTESTED**. Network roaming occurs when the phone goes through third-party telco services to perform a transaction, and is therefore only possible to test by going out of the country.\r\n\r\nA <code>BroadcastReceiver</code> called <code>GeneralBroadcastReceiver</code> has been set up to receive <code>android.net.conn.CONNECTIVITY_CHANGED</code> together with the other tasks that Omnitor fires.\r\n\r\n```xml\r\n<receiver android:name=\".GeneralBroadcastReceiver\">\r\n    <intent-filter>\r\n        <!-- other intent actions here -->\r\n        <action android:name=\"android.net.conn.CONNECTIVITY_CHANGED\" />\r\n    </intent-filter>\r\n</receiver>\r\n```\r\n\r\nSince the old network roaming state was remembered during the app's first launch, Omnitor simply gets the current roaming state when the above intent is fired. <code>GeneralBroadcastReceiver</code> then compares the two states and if they are not equal, <code>OutSmsLogger</code> and <code>DataLogger</code> are fired again to contain the **old** roaming state. This is because they are the only two loggers who are not able to record events as they happen in real-time. It is expected that from this point onward, any further triggers of <code>OutSmsLogger</code> and <code>DataLogger</code> will contain the **new** roaming state.\r\n\r\n## Uploading\r\n\r\nThe <code>Uploader</code>, as its name implies, performs the task of uploading. For Omnitor, the database is hosted in [MongoLab](http://mongolab.com) and accessed via their REST interface. Whenever fired, <code>Uploader</code> simply transforms all the logs in SQLite into a single, polymorphic JSON array and sends it to the server. If successful, the SQLite database is cleared. If not, the logs will be uploaded together with the new ones in the next schedule.\r\n\r\n## Thread collisions\r\n\r\nNote that the above tasks may be fired concurrently and arbitrarily. Synchronous access to the SQLite database is properly handled. However, since it's possible for the <code>Uploader</code> to finish before the other loggers, logs created after the upload will be uploaded in the next scheduled alarm.\r\n\r\n## About the Author\r\n\r\nI'm Matt Quiros, Android developer from the Philippines. My personal website's at [mattquiros.com](http://www.mattquiros.com).","google":"","tagline":"Tracks your consumption to find the best-suited mobile plan from a local telco."}